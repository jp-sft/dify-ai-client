/* tslint:disable */
/* eslint-disable */
/**
 * Chat Application API
 * API documentation for the Chat Application.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { ConversationRenameRequest } from '../models';
import { ConversationRenameResponse } from '../models';
import { DeleteConversationRequest } from '../models';
import { DeleteConversationResponse } from '../models';
import { ErrorResponse } from '../models';
import { FileUploadResponse } from '../models';
import { GetApplicationInfoResponse } from '../models';
import { GetApplicationMetaResponse } from '../models';
import { GetApplicationParametersResponse } from '../models';
import { GetConversationHistoryResponse } from '../models';
import { GetConversationsResponse } from '../models';
import { InlineResponse200 } from '../models';
import { MessageFeedbackRequest } from '../models';
import { MessageFeedbackResponse } from '../models';
import { NextSuggestedQuestionsResponse } from '../models';
import { SendChatMessageRequest } from '../models';
import { SpeechToTextResponse } from '../models';
import { StopGenerateRequest } from '../models';
import { StopGenerateResponse } from '../models';
import { TextToAudioRequest } from '../models';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Convert speech from an audio file to text.
         * @summary Speech to Text
         * @param {Blob} file 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioToTextPostForm: async (file: Blob, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling audioToTextPostForm.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling audioToTextPostForm.');
            }
            const localVarPath = `/audio-to-text`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            if (user !== undefined) { 
                localVarFormParams.append('user', user as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a request to the chat application.
         * @summary Send Chat Message
         * @param {SendChatMessageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatMessagesPost: async (body: SendChatMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling chatMessagesPost.');
            }
            const localVarPath = `/chat-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop generation of a message. Only supported in streaming mode.
         * @summary Stop Generate
         * @param {StopGenerateRequest} body 
         * @param {string} taskId Task ID, obtained from the streaming chunk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatMessagesTaskIdStopPost: async (body: StopGenerateRequest, taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling chatMessagesTaskIdStopPost.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling chatMessagesTaskIdStopPost.');
            }
            const localVarPath = `/chat-messages/{task_id}/stop`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a conversation.
         * @summary Delete Conversation
         * @param {DeleteConversationRequest} body 
         * @param {string} conversationId Conversation ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsConversationIdDelete: async (body: DeleteConversationRequest, conversationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling conversationsConversationIdDelete.');
            }
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling conversationsConversationIdDelete.');
            }
            const localVarPath = `/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Rename a conversation session. The session name is used for display on clients that support multiple sessions. 
         * @summary Conversation Rename
         * @param {ConversationRenameRequest} body 
         * @param {string} conversationId Conversation ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsConversationIdNamePost: async (body: ConversationRenameRequest, conversationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling conversationsConversationIdNamePost.');
            }
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling conversationsConversationIdNamePost.');
            }
            const localVarPath = `/conversations/{conversation_id}/name`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the conversation list for the current user, defaulting to the most recent 20 entries.
         * @summary Get Conversations
         * @param {string} user User identifier for retrieval and statistics.
         * @param {string} [lastId] The ID of the last record on the current page. Default is &#x60;null&#x60;.
         * @param {number} [limit] Number of records to return in one request. Maximum is 100, minimum is 1.
         * @param {string} [sortBy] Sorting field. Default: &#x60;-updated_at&#x60; (descending order by update time). Available Values: - &#x60;created_at&#x60; - &#x60;-created_at&#x60; - &#x60;updated_at&#x60; - &#x60;-updated_at&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGet: async (user: string, lastId?: string, limit?: number, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling conversationsGet.');
            }
            const localVarPath = `/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (lastId !== undefined) {
                localVarQueryParameter['last_id'] = lastId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a file for use when sending messages, enabling multimodal understanding of images and text. Supports any formats supported by your application. Uploaded files are accessible only to the current end-user. 
         * @summary File Upload
         * @param {Blob} file 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesUploadPostForm: async (file: Blob, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling filesUploadPostForm.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling filesUploadPostForm.');
            }
            const localVarPath = `/files/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            if (user !== undefined) { 
                localVarFormParams.append('user', user as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve basic information about the application.
         * @summary Get Application Basic Information
         * @param {string} user User identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoGet: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling infoGet.');
            }
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Return historical chat records in a scrolling load format, with the first page returning the latest `{limit}` messages in reverse order. 
         * @summary Get Conversation History Messages
         * @param {string} conversationId Conversation ID.
         * @param {string} user User identifier.
         * @param {string} [firstId] The ID of the first chat record on the current page. Default is &#x60;null&#x60;.
         * @param {number} [limit] Number of chat history messages to return in one request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesGet: async (conversationId: string, user: string, firstId?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling messagesGet.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling messagesGet.');
            }
            const localVarPath = `/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (conversationId !== undefined) {
                localVarQueryParameter['conversation_id'] = conversationId;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (firstId !== undefined) {
                localVarQueryParameter['first_id'] = firstId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * End-users can provide feedback on messages to help application developers optimize outputs. 
         * @summary Message Feedback
         * @param {MessageFeedbackRequest} body 
         * @param {string} messageId Message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIdFeedbacksPost: async (body: MessageFeedbackRequest, messageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling messagesMessageIdFeedbacksPost.');
            }
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling messagesMessageIdFeedbacksPost.');
            }
            const localVarPath = `/messages/{message_id}/feedbacks`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get next question suggestions for the current message.
         * @summary Next Suggested Questions
         * @param {string} messageId Message ID.
         * @param {string} user User identifier for retrieval and statistics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIdSuggestedGet: async (messageId: string, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling messagesMessageIdSuggestedGet.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling messagesMessageIdSuggestedGet.');
            }
            const localVarPath = `/messages/{message_id}/suggested`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve meta-information such as tool icons used in the application.
         * @summary Get Application Meta Information
         * @param {string} user User identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaGet: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling metaGet.');
            }
            const localVarPath = `/meta`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain application parameters such as features, input parameter names, types, and default values. Used at the start of entering the page. 
         * @summary Get Application Parameters Information
         * @param {string} user User identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parametersGet: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling parametersGet.');
            }
            const localVarPath = `/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Convert text to speech.
         * @summary Text to Audio
         * @param {TextToAudioRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textToAudioPost: async (body: TextToAudioRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling textToAudioPost.');
            }
            const localVarPath = `/text-to-audio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Convert speech from an audio file to text.
         * @summary Speech to Text
         * @param {Blob} file 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioToTextPostForm(file: Blob, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<SpeechToTextResponse>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).audioToTextPostForm(file, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Send a request to the chat application.
         * @summary Send Chat Message
         * @param {SendChatMessageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatMessagesPost(body: SendChatMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).chatMessagesPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Stop generation of a message. Only supported in streaming mode.
         * @summary Stop Generate
         * @param {StopGenerateRequest} body 
         * @param {string} taskId Task ID, obtained from the streaming chunk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatMessagesTaskIdStopPost(body: StopGenerateRequest, taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<StopGenerateResponse>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).chatMessagesTaskIdStopPost(body, taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a conversation.
         * @summary Delete Conversation
         * @param {DeleteConversationRequest} body 
         * @param {string} conversationId Conversation ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationsConversationIdDelete(body: DeleteConversationRequest, conversationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<DeleteConversationResponse>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).conversationsConversationIdDelete(body, conversationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Rename a conversation session. The session name is used for display on clients that support multiple sessions. 
         * @summary Conversation Rename
         * @param {ConversationRenameRequest} body 
         * @param {string} conversationId Conversation ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationsConversationIdNamePost(body: ConversationRenameRequest, conversationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ConversationRenameResponse>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).conversationsConversationIdNamePost(body, conversationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve the conversation list for the current user, defaulting to the most recent 20 entries.
         * @summary Get Conversations
         * @param {string} user User identifier for retrieval and statistics.
         * @param {string} [lastId] The ID of the last record on the current page. Default is &#x60;null&#x60;.
         * @param {number} [limit] Number of records to return in one request. Maximum is 100, minimum is 1.
         * @param {string} [sortBy] Sorting field. Default: &#x60;-updated_at&#x60; (descending order by update time). Available Values: - &#x60;created_at&#x60; - &#x60;-created_at&#x60; - &#x60;updated_at&#x60; - &#x60;-updated_at&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationsGet(user: string, lastId?: string, limit?: number, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetConversationsResponse>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).conversationsGet(user, lastId, limit, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upload a file for use when sending messages, enabling multimodal understanding of images and text. Supports any formats supported by your application. Uploaded files are accessible only to the current end-user. 
         * @summary File Upload
         * @param {Blob} file 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesUploadPostForm(file: Blob, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FileUploadResponse>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).filesUploadPostForm(file, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve basic information about the application.
         * @summary Get Application Basic Information
         * @param {string} user User identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoGet(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetApplicationInfoResponse>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).infoGet(user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return historical chat records in a scrolling load format, with the first page returning the latest `{limit}` messages in reverse order. 
         * @summary Get Conversation History Messages
         * @param {string} conversationId Conversation ID.
         * @param {string} user User identifier.
         * @param {string} [firstId] The ID of the first chat record on the current page. Default is &#x60;null&#x60;.
         * @param {number} [limit] Number of chat history messages to return in one request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesGet(conversationId: string, user: string, firstId?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetConversationHistoryResponse>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).messagesGet(conversationId, user, firstId, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * End-users can provide feedback on messages to help application developers optimize outputs. 
         * @summary Message Feedback
         * @param {MessageFeedbackRequest} body 
         * @param {string} messageId Message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesMessageIdFeedbacksPost(body: MessageFeedbackRequest, messageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MessageFeedbackResponse>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).messagesMessageIdFeedbacksPost(body, messageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get next question suggestions for the current message.
         * @summary Next Suggested Questions
         * @param {string} messageId Message ID.
         * @param {string} user User identifier for retrieval and statistics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesMessageIdSuggestedGet(messageId: string, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<NextSuggestedQuestionsResponse>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).messagesMessageIdSuggestedGet(messageId, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve meta-information such as tool icons used in the application.
         * @summary Get Application Meta Information
         * @param {string} user User identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaGet(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetApplicationMetaResponse>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).metaGet(user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Obtain application parameters such as features, input parameter names, types, and default values. Used at the start of entering the page. 
         * @summary Get Application Parameters Information
         * @param {string} user User identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parametersGet(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetApplicationParametersResponse>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).parametersGet(user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Convert text to speech.
         * @summary Text to Audio
         * @param {TextToAudioRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textToAudioPost(body: TextToAudioRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).textToAudioPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Convert speech from an audio file to text.
         * @summary Speech to Text
         * @param {Blob} file 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioToTextPostForm(file: Blob, user: string, options?: AxiosRequestConfig): Promise<AxiosResponse<SpeechToTextResponse>> {
            return DefaultApiFp(configuration).audioToTextPostForm(file, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a request to the chat application.
         * @summary Send Chat Message
         * @param {SendChatMessageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatMessagesPost(body: SendChatMessageRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200>> {
            return DefaultApiFp(configuration).chatMessagesPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop generation of a message. Only supported in streaming mode.
         * @summary Stop Generate
         * @param {StopGenerateRequest} body 
         * @param {string} taskId Task ID, obtained from the streaming chunk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatMessagesTaskIdStopPost(body: StopGenerateRequest, taskId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<StopGenerateResponse>> {
            return DefaultApiFp(configuration).chatMessagesTaskIdStopPost(body, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a conversation.
         * @summary Delete Conversation
         * @param {DeleteConversationRequest} body 
         * @param {string} conversationId Conversation ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationsConversationIdDelete(body: DeleteConversationRequest, conversationId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<DeleteConversationResponse>> {
            return DefaultApiFp(configuration).conversationsConversationIdDelete(body, conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rename a conversation session. The session name is used for display on clients that support multiple sessions. 
         * @summary Conversation Rename
         * @param {ConversationRenameRequest} body 
         * @param {string} conversationId Conversation ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationsConversationIdNamePost(body: ConversationRenameRequest, conversationId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ConversationRenameResponse>> {
            return DefaultApiFp(configuration).conversationsConversationIdNamePost(body, conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the conversation list for the current user, defaulting to the most recent 20 entries.
         * @summary Get Conversations
         * @param {string} user User identifier for retrieval and statistics.
         * @param {string} [lastId] The ID of the last record on the current page. Default is &#x60;null&#x60;.
         * @param {number} [limit] Number of records to return in one request. Maximum is 100, minimum is 1.
         * @param {string} [sortBy] Sorting field. Default: &#x60;-updated_at&#x60; (descending order by update time). Available Values: - &#x60;created_at&#x60; - &#x60;-created_at&#x60; - &#x60;updated_at&#x60; - &#x60;-updated_at&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationsGet(user: string, lastId?: string, limit?: number, sortBy?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<GetConversationsResponse>> {
            return DefaultApiFp(configuration).conversationsGet(user, lastId, limit, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a file for use when sending messages, enabling multimodal understanding of images and text. Supports any formats supported by your application. Uploaded files are accessible only to the current end-user. 
         * @summary File Upload
         * @param {Blob} file 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesUploadPostForm(file: Blob, user: string, options?: AxiosRequestConfig): Promise<AxiosResponse<FileUploadResponse>> {
            return DefaultApiFp(configuration).filesUploadPostForm(file, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve basic information about the application.
         * @summary Get Application Basic Information
         * @param {string} user User identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoGet(user: string, options?: AxiosRequestConfig): Promise<AxiosResponse<GetApplicationInfoResponse>> {
            return DefaultApiFp(configuration).infoGet(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Return historical chat records in a scrolling load format, with the first page returning the latest `{limit}` messages in reverse order. 
         * @summary Get Conversation History Messages
         * @param {string} conversationId Conversation ID.
         * @param {string} user User identifier.
         * @param {string} [firstId] The ID of the first chat record on the current page. Default is &#x60;null&#x60;.
         * @param {number} [limit] Number of chat history messages to return in one request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesGet(conversationId: string, user: string, firstId?: string, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<GetConversationHistoryResponse>> {
            return DefaultApiFp(configuration).messagesGet(conversationId, user, firstId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * End-users can provide feedback on messages to help application developers optimize outputs. 
         * @summary Message Feedback
         * @param {MessageFeedbackRequest} body 
         * @param {string} messageId Message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesMessageIdFeedbacksPost(body: MessageFeedbackRequest, messageId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<MessageFeedbackResponse>> {
            return DefaultApiFp(configuration).messagesMessageIdFeedbacksPost(body, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get next question suggestions for the current message.
         * @summary Next Suggested Questions
         * @param {string} messageId Message ID.
         * @param {string} user User identifier for retrieval and statistics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesMessageIdSuggestedGet(messageId: string, user: string, options?: AxiosRequestConfig): Promise<AxiosResponse<NextSuggestedQuestionsResponse>> {
            return DefaultApiFp(configuration).messagesMessageIdSuggestedGet(messageId, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve meta-information such as tool icons used in the application.
         * @summary Get Application Meta Information
         * @param {string} user User identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaGet(user: string, options?: AxiosRequestConfig): Promise<AxiosResponse<GetApplicationMetaResponse>> {
            return DefaultApiFp(configuration).metaGet(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain application parameters such as features, input parameter names, types, and default values. Used at the start of entering the page. 
         * @summary Get Application Parameters Information
         * @param {string} user User identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parametersGet(user: string, options?: AxiosRequestConfig): Promise<AxiosResponse<GetApplicationParametersResponse>> {
            return DefaultApiFp(configuration).parametersGet(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Convert text to speech.
         * @summary Text to Audio
         * @param {TextToAudioRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textToAudioPost(body: TextToAudioRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return DefaultApiFp(configuration).textToAudioPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Convert speech from an audio file to text.
     * @summary Speech to Text
     * @param {Blob} file 
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async audioToTextPostForm(file: Blob, user: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<SpeechToTextResponse>> {
        return DefaultApiFp(this.configuration).audioToTextPostForm(file, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send a request to the chat application.
     * @summary Send Chat Message
     * @param {SendChatMessageRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async chatMessagesPost(body: SendChatMessageRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200>> {
        return DefaultApiFp(this.configuration).chatMessagesPost(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Stop generation of a message. Only supported in streaming mode.
     * @summary Stop Generate
     * @param {StopGenerateRequest} body 
     * @param {string} taskId Task ID, obtained from the streaming chunk.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async chatMessagesTaskIdStopPost(body: StopGenerateRequest, taskId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<StopGenerateResponse>> {
        return DefaultApiFp(this.configuration).chatMessagesTaskIdStopPost(body, taskId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a conversation.
     * @summary Delete Conversation
     * @param {DeleteConversationRequest} body 
     * @param {string} conversationId Conversation ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async conversationsConversationIdDelete(body: DeleteConversationRequest, conversationId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<DeleteConversationResponse>> {
        return DefaultApiFp(this.configuration).conversationsConversationIdDelete(body, conversationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Rename a conversation session. The session name is used for display on clients that support multiple sessions. 
     * @summary Conversation Rename
     * @param {ConversationRenameRequest} body 
     * @param {string} conversationId Conversation ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async conversationsConversationIdNamePost(body: ConversationRenameRequest, conversationId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ConversationRenameResponse>> {
        return DefaultApiFp(this.configuration).conversationsConversationIdNamePost(body, conversationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the conversation list for the current user, defaulting to the most recent 20 entries.
     * @summary Get Conversations
     * @param {string} user User identifier for retrieval and statistics.
     * @param {string} [lastId] The ID of the last record on the current page. Default is &#x60;null&#x60;.
     * @param {number} [limit] Number of records to return in one request. Maximum is 100, minimum is 1.
     * @param {string} [sortBy] Sorting field. Default: &#x60;-updated_at&#x60; (descending order by update time). Available Values: - &#x60;created_at&#x60; - &#x60;-created_at&#x60; - &#x60;updated_at&#x60; - &#x60;-updated_at&#x60; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async conversationsGet(user: string, lastId?: string, limit?: number, sortBy?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetConversationsResponse>> {
        return DefaultApiFp(this.configuration).conversationsGet(user, lastId, limit, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload a file for use when sending messages, enabling multimodal understanding of images and text. Supports any formats supported by your application. Uploaded files are accessible only to the current end-user. 
     * @summary File Upload
     * @param {Blob} file 
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async filesUploadPostForm(file: Blob, user: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<FileUploadResponse>> {
        return DefaultApiFp(this.configuration).filesUploadPostForm(file, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve basic information about the application.
     * @summary Get Application Basic Information
     * @param {string} user User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async infoGet(user: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetApplicationInfoResponse>> {
        return DefaultApiFp(this.configuration).infoGet(user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Return historical chat records in a scrolling load format, with the first page returning the latest `{limit}` messages in reverse order. 
     * @summary Get Conversation History Messages
     * @param {string} conversationId Conversation ID.
     * @param {string} user User identifier.
     * @param {string} [firstId] The ID of the first chat record on the current page. Default is &#x60;null&#x60;.
     * @param {number} [limit] Number of chat history messages to return in one request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async messagesGet(conversationId: string, user: string, firstId?: string, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetConversationHistoryResponse>> {
        return DefaultApiFp(this.configuration).messagesGet(conversationId, user, firstId, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * End-users can provide feedback on messages to help application developers optimize outputs. 
     * @summary Message Feedback
     * @param {MessageFeedbackRequest} body 
     * @param {string} messageId Message ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async messagesMessageIdFeedbacksPost(body: MessageFeedbackRequest, messageId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<MessageFeedbackResponse>> {
        return DefaultApiFp(this.configuration).messagesMessageIdFeedbacksPost(body, messageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get next question suggestions for the current message.
     * @summary Next Suggested Questions
     * @param {string} messageId Message ID.
     * @param {string} user User identifier for retrieval and statistics.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async messagesMessageIdSuggestedGet(messageId: string, user: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<NextSuggestedQuestionsResponse>> {
        return DefaultApiFp(this.configuration).messagesMessageIdSuggestedGet(messageId, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve meta-information such as tool icons used in the application.
     * @summary Get Application Meta Information
     * @param {string} user User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async metaGet(user: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetApplicationMetaResponse>> {
        return DefaultApiFp(this.configuration).metaGet(user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Obtain application parameters such as features, input parameter names, types, and default values. Used at the start of entering the page. 
     * @summary Get Application Parameters Information
     * @param {string} user User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async parametersGet(user: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetApplicationParametersResponse>> {
        return DefaultApiFp(this.configuration).parametersGet(user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Convert text to speech.
     * @summary Text to Audio
     * @param {TextToAudioRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async textToAudioPost(body: TextToAudioRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return DefaultApiFp(this.configuration).textToAudioPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}
